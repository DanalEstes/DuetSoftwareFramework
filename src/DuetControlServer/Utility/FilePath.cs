using System.IO;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace DuetControlServer
{
    /// <summary>
    /// Static class used to provide functions for file path resolution
    /// </summary>
    public static class FilePath
    {
        /// <summary>
        /// Default name of the config file
        /// </summary>
        public const string ConfigFile = "config.g";

        /// <summary>
        /// Fallback file if the config file could not be found
        /// </summary>
        public const string ConfigFileFallback = "config.g.bak";

        /// <summary>
        /// Config override as generated by M500
        /// </summary>
        public const string ConfigOverrideFile = "config-override.g";

        /// <summary>
        /// Default heightmap file
        /// </summary>
        public const string DefaultHeightmapFile = "heightmap.csv";

        /// <summary>
        /// File holding the filaments mapping
        /// </summary>
        public const string FilamentsFile = "filaments.csv";

        /// <summary>
        /// Macro file to run when a file print is being started
        /// </summary>
        public const string StartMacroFile = "start.g";

        /// <summary>
        /// Resolve a RepRapFirmware/FatFs-style file path to a physical file path.
        /// The first drive (0:/) is reserved for usage with the base directory as specified in the settings.
        /// </summary>
        /// <param name="filePath">File path to resolve</param>
        /// <param name="directory">Directory of the file path if none is specified</param>
        /// <returns>Resolved file path</returns>
        public static string ToPhysical(string filePath, string directory = null)
        {
            Match match = Regex.Match(filePath, "^(\\d+):?/?(.*)");
            if (match.Success)
            {
                int driveNumber = int.Parse(match.Groups[1].Value);
                if (driveNumber == 0)
                {
                    return Path.Combine(Path.GetFullPath(Settings.BaseDirectory), match.Groups[2].Value);
                }

                using (Model.Provider.AccessReadOnly())
                {
                    if (driveNumber > 0 && driveNumber < Model.Provider.Get.Storages.Count)
                    {
                        return Path.Combine(Model.Provider.Get.Storages[driveNumber].Path, match.Groups[2].Value);
                    }
                }
            }

            if (directory != null && !filePath.StartsWith('/'))
            {
                return Path.Combine(Path.GetFullPath(Settings.BaseDirectory), directory, filePath);
            }
            return Path.Combine(Path.GetFullPath(Settings.BaseDirectory), filePath.StartsWith('/') ? filePath.Substring(1) : filePath);
        }

        /// <summary>
        /// Resolve a RepRapFirmware/FatFs-style file path to a physical file path asynchronously.
        /// The first drive (0:/) is reserved for usage with the base directory as specified in the settings.
        /// </summary>
        /// <param name="filePath">File path to resolve</param>
        /// <param name="directory">Directory of the file path if none is specified</param>
        /// <returns>Resolved file path</returns>
        public static async Task<string> ToPhysicalAsync(string filePath, string directory = null)
        {
            Match match = Regex.Match(filePath, "^(\\d+):?/?(.*)");
            if (match.Success)
            {
                int driveNumber = int.Parse(match.Groups[1].Value);
                if (driveNumber == 0)
                {
                    return Path.Combine(Path.GetFullPath(Settings.BaseDirectory), match.Groups[2].Value);
                }

                using (await Model.Provider.AccessReadOnlyAsync())
                {
                    if (driveNumber > 0 && driveNumber < Model.Provider.Get.Storages.Count)
                    {
                        return Path.Combine(Model.Provider.Get.Storages[driveNumber].Path, match.Groups[2].Value);
                    }
                }
            }

            if (directory != null && !filePath.StartsWith('/'))
            {
                return Path.Combine(Path.GetFullPath(Settings.BaseDirectory), directory, filePath);
            }
            return Path.Combine(Path.GetFullPath(Settings.BaseDirectory), filePath.StartsWith('/') ? filePath.Substring(1) : filePath);
        }

        /// <summary>
        /// Convert a physical ile path to a RRF-style file path.
        /// The first drive (0:/) is reserved for usage with the base directory as specified in the settings.
        /// </summary>
        /// <param name="filePath">File path to convert</param>
        /// <returns>Resolved file path</returns>
        public static string ToVirtual(string filePath)
        {
            if (filePath.StartsWith(Settings.BaseDirectory))
            {
                filePath = filePath.Substring(Settings.BaseDirectory.EndsWith('/') ? Settings.BaseDirectory.Length : (Settings.BaseDirectory.Length + 1));
                return Path.Combine("0:/", filePath);
            }

            using (Model.Provider.AccessReadOnly())
            {
                foreach (var storage in Model.Provider.Get.Storages)
                {
                    if (filePath.StartsWith(storage.Path))
                    {
                        return Path.Combine("0:/", filePath.Substring(storage.Path.Length));
                    }
                }
            }

            return Path.Combine("0:/", filePath);
        }

        /// <summary>
        /// Convert a physical ile path to a RRF-style file path asynchronously.
        /// The first drive (0:/) is reserved for usage with the base directory as specified in the settings.
        /// </summary>
        /// <param name="filePath">File path to convert</param>
        /// <returns>Resolved file path</returns>
        public static async Task<string> ToVirtualAsync(string filePath)
        {
            if (filePath.StartsWith(Settings.BaseDirectory))
            {
                filePath = filePath.Substring(Settings.BaseDirectory.EndsWith('/') ? Settings.BaseDirectory.Length : (Settings.BaseDirectory.Length + 1));
                return Path.Combine("0:/", filePath);
            }

            using (await Model.Provider.AccessReadOnlyAsync())
            {
                foreach (var storage in Model.Provider.Get.Storages)
                {
                    if (filePath.StartsWith(storage.Path))
                    {
                        return Path.Combine("0:/", filePath.Substring(storage.Path.Length));
                    }
                }
            }

            return Path.Combine("0:/", filePath);
        }
    }
}
