using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using DuetAPI;
using DuetAPI.Commands;
using Code = DuetControlServer.Commands.Code;

namespace DuetControlServer.FileExecution
{
    /// <summary>
    /// Implementation of a macro file
    /// </summary>
    public class MacroFile : BaseFile
    {
        /// <summary>
        /// Default name of the config file
        /// </summary>
        public static readonly string ConfigFile = "config.g";

        /// <summary>
        /// Fallback file if the config file could not be found
        /// </summary>
        public static readonly string ConfigFileFallback = "config.g.bak";

        /// <summary>
        /// Config override as generated by M500
        /// </summary>
        public static readonly string ConfigOverrideFile = "config-override.g";

        /// <summary>
        /// List of macro files being executed
        /// </summary>
        private static readonly List<MacroFile> _macroFiles = new List<MacroFile>();

        /// <summary>
        /// Indicates if a file macro is being done
        /// </summary>
        public static bool DoingMacroFile
        {
            get
            {
                lock (_macroFiles)
                {
                    return _macroFiles.Count != 0;
                }
            }
        }

        /// <summary>
        /// Abort files on the given channel (probably because the firmware requested this)
        /// </summary>
        /// <param name="channel">Channel on which macros are supposed to be cancelled</param>
        public static void AbortAllFiles(CodeChannel channel)
        {
            lock (_macroFiles)
            {
                foreach (MacroFile file in _macroFiles)
                {
                    if (file.Channel == channel)
                    {
                        file.Abort();
                    }
                }
            }
        }

        /// <summary>
        /// Abort the last file on the given channel
        /// </summary>
        /// <param name="channel">Channel of the running macro file</param>
        /// <returns>If an abortion could be requested</returns>
        public static bool AbortLastFile(CodeChannel channel)
        {
            lock (_macroFiles)
            {
                for (int i = _macroFiles.Count - 1; i >= 0; i--)
                {
                    MacroFile file = _macroFiles[i];
                    if (file.Channel == channel)
                    {
                        file.Abort();
                        return true;
                    }
                }
            }
            return false;
        }

        private readonly bool _isConfig;
        private readonly bool _isConfigOverride;
        private readonly bool _isSystemMacro;
        private bool _sentPush, _sentPop;
        private readonly int _sourceConnection;

        /// <summary>
        /// Create a new macro instance
        /// </summary>
        /// <param name="fileName">Filename of the macro</param>
        /// <param name="channel">Channel to send the codes to</param>
        /// <param name="isSystemMacro">Whether the macro file is requested from the firmware</param>
        /// <param name="sourceConnection">Source connection of this macro</param>
        public MacroFile(string fileName, CodeChannel channel, bool isSystemMacro, int sourceConnection) : base(fileName, channel)
        {
            string name = Path.GetFileName(fileName);
            _isConfig = (name == ConfigFile || name == ConfigFileFallback);
            _isConfigOverride = (name == ConfigOverrideFile);
            _isSystemMacro = isSystemMacro;
            _sourceConnection = sourceConnection;
            lock (_macroFiles)
            {
                _macroFiles.Add(this);
            }

            Console.WriteLine($"[info] Executing {(isSystemMacro ? "system" : "regular")} macro file '{fileName}' on channel {channel}");
        }

        /// <summary>
        /// Print diagnostics of this class
        /// </summary>
        /// <param name="builder">String builder</param>
        public static void Diagnostics(StringBuilder builder)
        {
            lock (_macroFiles)
            {
                foreach (MacroFile file in _macroFiles)
                {
                    builder.AppendLine($"Executing {(file._isSystemMacro ? "system" : "regular")} macro file '{file.FileName}' on channel {file.Channel}");
                }
            }
        }

        /// <summary>
        /// Read another code from the file being executed asynchronously
        /// </summary>
        /// <returns>Next available code or null if the file has ended</returns>
        public override Code ReadCode()
        {
            // Push the stack unless the firmware requested this file (M120)
            if (!_sentPush && !_isSystemMacro)
            {
                _sentPush = true;
                return new Code
                {
                    Channel = Channel,
                    IsFromMacro = true,
                    SourceConnection = _sourceConnection,
                    Type = CodeType.MCode,
                    MajorNumber = 120
                };
            }

            // Read the next code from the file
            Code result = base.ReadCode();
            if (result != null)
            {
                result.FilePosition = null;
                result.IsFromConfig = _isConfig;
                result.IsFromConfigOverride = _isConfigOverride;
                result.IsFromMacro = true;
                result.IsFromSystemMacro = _isSystemMacro;
                result.SourceConnection = _sourceConnection;
                return result;
            }

            // Pop the stack before regular completion (M121)
            if (_sentPop && !_isSystemMacro && !IsAborted)
            {
                _sentPop = true;
                return new Code
                {
                    Channel = Channel,
                    IsFromMacro = true,
                    SourceConnection = _sourceConnection,
                    Type = CodeType.MCode,
                    MajorNumber = 121
                };
            }

            // Remove reference to this file again
            lock (_macroFiles)
            {
                _macroFiles.Remove(this);
            }
            return null;
        }

        /// <summary>
        /// Read another code from the file being executed asynchronously
        /// </summary>
        /// <returns>Next available code or null if the file has ended</returns>
        public override async Task<Code> ReadCodeAsync()
        {
            // Push the stack unless the firmware requested this file (M120)
            if (!_sentPush && !_isSystemMacro)
            {
                _sentPush = true;
                return new Code
                {
                    Channel = Channel,
                    IsFromMacro = true,
                    SourceConnection = _sourceConnection,
                    Type = CodeType.MCode,
                    MajorNumber = 120
                };
            }

            // Read the next code from the file
            Code result = await base.ReadCodeAsync();
            if (result != null)
            {
                result.FilePosition = null;
                result.IsFromConfig = _isConfig;
                result.IsFromConfigOverride = _isConfigOverride;
                result.IsFromMacro = true;
                result.IsFromSystemMacro = _isSystemMacro;
                result.SourceConnection = _sourceConnection;
                return result;
            }

            // Pop the stack before regular completion (M121)
            if (_sentPop && !_isSystemMacro && !IsAborted)
            {
                _sentPop = true;
                return new Code
                {
                    Channel = Channel,
                    IsFromMacro = true,
                    SourceConnection = _sourceConnection,
                    Type = CodeType.MCode,
                    MajorNumber = 121
                };
            }

            // Remove reference to this file again
            lock (_macroFiles)
            {
                _macroFiles.Remove(this);
            }
            return null;
        }

        /// <summary>
        /// Execute the full macro file
        /// </summary>
        /// <returns>Asynchronous task</returns>
        public async Task RunMacro()
        {
            for (Code code = await ReadCodeAsync(); code != null; code = await ReadCodeAsync())
            {
                CodeResult result = await code.Execute();
                if (!IsAborted)
                {
                    await Model.Provider.Output(result);
                }
            }

            Console.WriteLine($"[info] {(IsAborted ? "Aborted" : "Finished")} execution of macro file '{FileName}'");
        }
    }
}
